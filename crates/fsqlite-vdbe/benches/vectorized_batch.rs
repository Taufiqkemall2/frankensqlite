use criterion::{BenchmarkId, Criterion, criterion_group, criterion_main};
use fsqlite_types::value::SqliteValue;
use fsqlite_vdbe::vectorized::{Batch, ColumnSpec, ColumnVectorType, DEFAULT_BATCH_ROW_CAPACITY};

fn benchmark_specs() -> Vec<ColumnSpec> {
    vec![
        ColumnSpec::new("id", ColumnVectorType::Int64),
        ColumnSpec::new("score", ColumnVectorType::Float64),
        ColumnSpec::new("payload", ColumnVectorType::Binary),
        ColumnSpec::new("name", ColumnVectorType::Text),
    ]
}

fn build_rows(row_count: usize) -> Vec<Vec<SqliteValue>> {
    let mut rows = Vec::with_capacity(row_count);
    for row_id in 0..row_count {
        let payload = vec![
            u8::try_from(row_id & 0xFF).expect("low byte should fit into u8"),
            u8::try_from((row_id >> 8) & 0xFF).expect("middle byte should fit into u8"),
            u8::try_from((row_id >> 16) & 0xFF).expect("high byte should fit into u8"),
        ];
        rows.push(vec![
            SqliteValue::Integer(i64::try_from(row_id).expect("row id should fit into i64")),
            SqliteValue::Float(row_id as f64 * 1.25),
            SqliteValue::Blob(payload),
            SqliteValue::Text(format!("row-{row_id:04}")),
        ]);
    }
    rows
}

fn bench_batch_construction(c: &mut Criterion) {
    let specs = benchmark_specs();
    let mut group = c.benchmark_group("vectorized_batch_construction");

    for row_count in [64_usize, 256, DEFAULT_BATCH_ROW_CAPACITY] {
        let rows = build_rows(row_count);
        group.bench_with_input(BenchmarkId::from_parameter(row_count), &rows, |b, rows| {
            b.iter(|| {
                let batch = Batch::from_rows(rows, &specs, DEFAULT_BATCH_ROW_CAPACITY)
                    .expect("batch construction should succeed");
                criterion::black_box(batch);
            });
        });
    }

    group.finish();
}

criterion_group!(benches, bench_batch_construction);
criterion_main!(benches);
